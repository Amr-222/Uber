@model Uber.DAL.Entities.Ride

@{
    ViewData["Title"] = "Ride Details";
    var isDriver = User.IsInRole("Driver") || User.IsInRole("Admin");
    var isUser = User.IsInRole("User") || User.IsInRole("Admin");
}

<!-- Map CSS and JS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- Fallback CDN links in case the main ones fail -->
<script>
    // Check if Leaflet loaded from primary CDN
    if (typeof L === 'undefined') {
        // Load from fallback CDN
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css';
        document.head.appendChild(link);
        
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js';
        script.onload = function() {
        };
        script.onerror = function() {
            console.error('Both Leaflet CDNs failed to load');
        };
        document.head.appendChild(script);
    }
</script>

<style>
    #rideMap {
        width: 100%;
        height: 400px;
        border-radius: 10px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        position: relative;
        z-index: 1;
        background-color: #f0f0f0; /* Add background color to make it visible */
        border: 2px solid #ddd; /* Add border to make it more visible */
    }
    
    /* Ensure the map container is properly sized */
    .map-container {
        background-color: white;
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        position: relative;
    }
    
    /* Force the map to be visible */
    .map-container #rideMap {
        min-height: 400px;
        display: block !important;
        visibility: visible !important;
    }
    
    .map-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-top: 15px;
    }
    
    .map-info-item {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        text-align: center;
    }
    
    .map-info-item h5 {
        margin: 0 0 10px 0;
        color: #6c757d;
        font-size: 14px;
    }
    
    .map-info-item p {
        margin: 0;
        font-weight: bold;
        color: #495057;
        font-size: 18px;
    }
</style>

<div style="max-width: 1000px; margin: 0 auto; padding: 20px;">
    <div style="text-align: center; margin-bottom: 30px;">
        <h2 style="color: #007bff;">üöó Active Ride</h2>
        <div style="display: inline-block; padding: 8px 16px; background-color: #28a745; color: white; border-radius: 20px; font-weight: bold;">
            Ride ID: @Model.Id
        </div>
    </div>

    <!-- Ride Status -->
    <div class="ride-status-info" style="background-color: #e8f5e8; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #28a745;">
        <h4 style="color: #28a745; margin: 0;">
            @switch (Model.Status)
            {
                case Uber.DAL.Enums.RideStatus.Pending:
                    <text>‚è≥ Ride Pending</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Accepted:
                    <text>‚úÖ Ride Accepted</text>
                    break;
                case Uber.DAL.Enums.RideStatus.InProgress:
                    <text>üöÄ Ride In Progress</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Completed:
                    <text>‚úÖ Ride Completed</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Cancelled:
                    <text>‚ùå Ride Cancelled</text>
                    break;
                default:
                    <text>‚úÖ Ride Accepted</text>
                    break;
            }
        </h4>
        <p style="margin: 10px 0 0 0; color: #2d5a2d;">
            @switch (Model.Status)
            {
                case Uber.DAL.Enums.RideStatus.Pending:
                    <text>Waiting for driver to accept your ride request.</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Accepted:
                    <text>Your ride is confirmed and on the way!</text>
                    break;
                case Uber.DAL.Enums.RideStatus.InProgress:
                    <text>Your ride is now in progress!</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Completed:
                    <text>Your ride has been completed successfully!</text>
                    break;
                case Uber.DAL.Enums.RideStatus.Cancelled:
                    <text>This ride has been cancelled.</text>
                    break;
                default:
                    <text>Your ride is confirmed and on the way!</text>
                    break;
            }
        </p>
    </div>

    <!-- Map Section -->
    <div class="map-container">
        <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üó∫Ô∏è Ride Route</h4>
        <div id="rideMap">
        </div>
        
        
        
        <!-- SignalR Status Indicator -->
        <div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; text-align: center;">
            <strong>SignalR Status:</strong> 
            <span id="signalRStatus" style="padding: 5px 10px; border-radius: 3px; font-weight: bold; margin-left: 10px;">
                Connecting...
            </span>
        </div>
        
        
        
        <div class="map-info">
            <div class="map-info-item">
                <h5>üöÄ Price</h5>
                <p id="price">Calculating...</p>
            </div>
            <div class="map-info-item">
                <h5 style="color: #6c757d; margin-bottom: 10px;">üîÑ Status</h5>
                <span id="statusBadge" style="padding: 5px 12px; background-color: #28a745; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">
                    @Model.Status.ToString()
                </span>
            </div>
            <div class="map-info-item">
                <h5>üìè Distance</h5>
                <p id="routeDistance">Calculating...</p>
            </div>
            <div class="map-info-item">
                <h5>‚è±Ô∏è Duration</h5>
                <p id="routeDuration">Calculating...</p>
            </div>
        </div>
    </div>

    @* <!-- Ride Information -->
    <div style="background-color: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
        <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üìç Ride Details</h4>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            <div>
                <h5 style="color: #6c757d; margin-bottom: 10px;">üöÄ Pickup Location</h5>
                <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px;">
                    <p style="margin: 0; font-weight: bold;">@Model.StartLat.ToString("F6"), @Model.StartLng.ToString("F6")</p>
                    <small style="color: #6c757d;">Latitude, Longitude</small>
                </div>
            </div>
            
            <div>
                <h5 style="color: #6c757d; margin-bottom: 10px;">üéØ Destination</h5>
                <div style="background-color: #f8f9fa; padding: 15px; border-radius: 5px;">
                    <p style="margin: 0; font-weight: bold;">@Model.EndLat.ToString("F6"), @Model.EndLng.ToString("F6")</p>
                    <small style="color: #6c757d;">Latitude, Longitude</small>
                </div>
            </div>
        </div>

        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e9ecef;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                <div>
                    <h5 style="color: #6c757d; margin-bottom: 10px;">üìÖ Request Time</h5>
                    <p style="margin: 0; font-weight: bold;">@Model.CreatedAt.ToString("MMM dd, yyyy HH:mm")</p>
                </div>
                
                <div>
                    <h5 style="color: #6c757d; margin-bottom: 10px;">üîÑ Status</h5>
                    <span style="padding: 5px 12px; background-color: #28a745; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">
                        @Model.Status.ToString()
                    </span>
                </div>
            </div>
        </div>
    </div> *@

    <!-- Driver Information (if user is viewing) -->
    @if (isUser && Model.Driver != null)
    {
        <div style="background-color: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
            <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üë®‚Äçüíº Driver Information</h4>
            
            <div style="display: flex; align-items: center; gap: 20px;">
                <div style="width: 60px; height: 60px; background-color: #007bff; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">
                    @(Model.Driver.UserName?.Substring(0, 1).ToUpper() ?? "D")
                </div>
                
                <div>
                    <h5 style="margin: 0; color: #495057;">@Model.Driver.UserName</h5>
                    <p style="margin: 5px 0 0 0; color: #6c757d;">Your assigned driver</p>
                </div>
            </div>
        </div>
    }

    <!-- User Information (if driver is viewing) -->
    @if (isDriver && Model.User != null)
    {
        <div style="background-color: white; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 20px;">
            <h4 style="color: #495057; margin-bottom: 20px; border-bottom: 2px solid #e9ecef; padding-bottom: 10px;">üë§ Passenger Information</h4>
            
            <div style="display: flex; align-items: center; gap: 20px;">
                <div style="width: 60px; height: 60px; background-color: #6c757d; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">
                    @(Model.User.UserName?.Substring(0, 1).ToUpper() ?? "U")
                </div>
                
                <div>
                    <h5 style="margin: 0; color: #495057;">@Model.User.UserName</h5>
                    <p style="margin: 5px 0 0 0; color: #6c757d;">Your passenger</p>
                </div>
            </div>
        </div>
    }

    <!-- Action Buttons -->
    <div class="action-buttons" style="text-align: center; margin-top: 30px;">
        @if (isDriver)
        {
            <button onclick="startRide()" style="padding: 15px 30px; background-color: #007bff; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px;">
                üöÄ Start Ride
            </button>
            <button onclick="completeRide()" style="padding: 15px 30px; background-color: #28a745; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px;">
                ‚úÖ Complete Ride
            </button>
        }
        
        <!-- Cancel Ride Button - Visible for both roles unless ride is completed or cancelled -->
        @if (Model.Status != Uber.DAL.Enums.RideStatus.Completed && Model.Status != Uber.DAL.Enums.RideStatus.Cancelled)
        {
            <button id="cancelRideBtn" onclick="cancelRide()" style="padding: 15px 30px; background-color: #dc3545; color: white; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin: 0 10px;">
                ‚ùå Cancel Ride
            </button>
        }
        
        <!-- Back to Home Button - Only visible when ride is completed or cancelled -->
        @if (Model.Status == Uber.DAL.Enums.RideStatus.Completed || Model.Status == Uber.DAL.Enums.RideStatus.Cancelled)
        {
        <a href="/Home" style="display: inline-block; padding: 15px 30px; background-color: #6c757d; color: white; text-decoration: none; border-radius: 8px; font-size: 16px; margin: 0 10px;">
            üè† Back to Home
        </a>
        }
    </div>

    <!-- Real-time Updates -->
    <div id="rideUpdates" style="margin-top: 30px; padding: 20px; background-color: #f8f9fa; border-radius: 8px; display: none;">
        <h4 style="color: #495057; margin-bottom: 15px;">üîÑ Live Updates</h4>
        <div id="updateContent"></div>
    </div>
</div>




<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.1/signalr.min.js"></script>
<script>

    window.addEventListener("load", initializeMap);

    let connection;
    let isConnected = false;
    let map, pickupMarker, dropoffMarker, routeLine;

    // Initialize map
    function initializeMap() {
             // Prevent multiple map initializations
             if (window.mapInitialized) {
                 return;
             }
        
        // Check if Leaflet is loaded
        if (typeof L === 'undefined') {
            console.error('Leaflet library not loaded!');
            return;
        }
        
        // Validate coordinates
        const startLat = @Model.StartLat;
        const startLng = @Model.StartLng;
        const endLat = @Model.EndLat;
        const endLng = @Model.EndLng;
        
        // Check if coordinates are valid numbers
        if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) {
            console.error('Invalid coordinates detected, using fallback coordinates');
            // Use fallback coordinates (New York City area)
            const fallbackStartLat = 40.7128;
            const fallbackStartLng = -74.0060;
            const fallbackEndLat = 40.7589;
            const fallbackEndLng = -73.9851;
            
            initializeMapWithCoordinates(fallbackStartLat, fallbackStartLng, fallbackEndLat, fallbackEndLng);
            return;
        }
        
        initializeMapWithCoordinates(startLat, startLng, endLat, endLng);
    }
    
    function initializeMapWithCoordinates(startLat, startLng, endLat, endLng) {
        try {
            // Create map centered between pickup and destination
            const centerLat = (startLat + endLat) / 2;
            const centerLng = (startLng + endLng) / 2;
            
            map = L.map('rideMap').setView([centerLat, centerLng], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            // Add pickup and dropoff markers
            pickupMarker = L.marker([startLat, startLng], {
                icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684908.png',
                    iconSize: [32, 32]
                })
            }).addTo(map).bindPopup("üöÄ Pickup Location").openPopup();

            dropoffMarker = L.marker([endLat, endLng], {
                icon: L.icon({
                    iconUrl: 'https://cdn-icons-png.flaticon.com/512/684/684909.png',
                    iconSize: [32, 32]
                })
            }).addTo(map).bindPopup("üéØ Destination").openPopup();

            // Draw route between points
            drawRouteWithCoordinates(startLat, startLng, endLat, endLng);
             
             // Mark map as initialized
             window.mapInitialized = true;
        } catch (error) {
            console.error('Error initializing map:', error);
        }
    }

    // Draw route between points
    async function drawRoute() {
        try {
            const start = [@Model.StartLat, @Model.StartLng];
            const end = [@Model.EndLat, @Model.EndLng];

            const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`);
            const data = await response.json();

            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                const path = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);

                // Remove existing route line if any
                if (routeLine) {
                    map.removeLayer(routeLine);
                }

                // Draw new route line
                routeLine = L.polyline(path, { color: '#007bff', weight: 4, opacity: 0.8 }).addTo(map);

                // Fit map to show entire route
                map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });

                // Update distance and duration
                const distance = (route.distance / 1000).toFixed(2);
                const duration = (route.duration / 60).toFixed(1);

                document.getElementById('routeDistance').textContent = distance + ' km';
                document.getElementById('routeDuration').textContent = duration + ' min';
                document.getElementById('price').textContent = (distance * 7 + duration * 1.5 + 7).toFixed(2) + 'pound';
            }
        } catch (error) {
            console.error('Error drawing route:', error);
            document.getElementById('routeDistance').textContent = 'Error';
            document.getElementById('routeDuration').textContent = 'Error';
            document.getElementById('price').textContent = 'Error';
        }
    }
    
    async function drawRouteWithCoordinates(startLat, startLng, endLat, endLng) {
        try {
            const start = [startLat, startLng];
            const end = [endLat, endLng];

            const response = await fetch(`https://router.project-osrm.org/route/v1/driving/${start[1]},${start[0]};${end[1]},${end[0]}?overview=full&geometries=geojson`);
            const data = await response.json();

            if (data.routes && data.routes.length > 0) {
                const route = data.routes[0];
                const path = route.geometry.coordinates.map(coord => [coord[1], coord[0]]);

                // Remove existing route line if any
                if (routeLine) {
                    map.removeLayer(routeLine);
                }

                // Draw new route line
                routeLine = L.polyline(path, { color: '#007bff', weight: 4, opacity: 0.8 }).addTo(map);

                // Fit map to show entire route
                map.fitBounds(routeLine.getBounds(), { padding: [20, 20] });

                // Update distance and duration
                const distance = (route.distance / 1000).toFixed(2);
                const duration = (route.duration / 60).toFixed(1);
                const price = (distance * 7 + duration * 1.5 + 7).toFixed(2)

                document.getElementById('routeDistance').textContent = distance + ' km';
                document.getElementById('routeDuration').textContent = duration + ' min';
                document.getElementById('price').textContent = price + 'pound';
            }
        } catch (error) {
            console.error('Error drawing route:', error);
            document.getElementById('routeDistance').textContent = 'Error';
            document.getElementById('routeDuration').textContent = 'Error';
            document.getElementById('price').textContent = 'Error';

         }
     }

                  // Function to join driver group if user is a driver
         async function joinDriverGroupIfNeeded() {
             @if (isDriver)
             {
                 <text>
                 const driverId = '@User.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value';
                 if (driverId && driverId !== '') {
                     try {
                         await connection.invoke("JoinDriverGroup", driverId);
                     } catch (err) {
                         console.error("Failed to join driver group:", err);
                     }
                 }
                 </text>
        }
    }

    // Initialize SignalR connection for real-time updates
    async function initializeConnection() {
        try {
            connection = new signalR.HubConnectionBuilder()
                .withUrl("/rideHub", { 
                    skipNegotiation: true,
                    transport: signalR.HttpTransportType.WebSockets
                })
                .withAutomaticReconnect()
                .build();

            // Join the ride group for updates
            await connection.start();
                 
                 // Join the ride group
            await connection.invoke("JoinRideGroup", "ride-@Model.Id");
 
                 // Join driver group if user is a driver
                 await joinDriverGroupIfNeeded();
                 
                 isConnected = true;
                 updateSignalRStatus("Connected", "#28a745");
                 
                 // Set up SignalR event listeners
                 setupSignalRListeners();
                 
                 // Add connection state monitoring
                 connection.onclose(async (error) => {
                     isConnected = false;
                     updateSignalRStatus("Disconnected", "#dc3545");
                     
                     // Try to reconnect after a delay
                     setTimeout(async () => {
                         await initializeConnection();
                     }, 3000);
                 });
                 
                 // Add periodic connection health check
                 setInterval(async () => {
                     if (connection && connection.state === signalR.HubConnectionState.Connected) {
                         isConnected = true;
                         updateSignalRStatus("Connected", "#28a745");
                     } else if (connection && connection.state !== signalR.HubConnectionState.Connected) {
                         isConnected = false;
                         updateSignalRStatus("Reconnecting...", "#ffc107");
                         try {
                             await initializeConnection();
                         } catch (error) {
                             console.error("Health check reconnection failed:", error);
                         }
                     }
                 }, 10000); // Check every 10 seconds
                 
                 connection.onreconnecting((error) => {
                     isConnected = false;
                     updateSignalRStatus("Reconnecting...", "#ffc107");
                 });
                 
                 connection.onreconnected((connectionId) => {
            isConnected = true;
                     updateSignalRStatus("Connected", "#28a745");
                 });

        } catch (err) {
            console.error("SignalR Connection Error:", err);
                 isConnected = false;
                 updateSignalRStatus("Error", "#dc3545");
             }
         }
    
         // Function to update SignalR status display
     function updateSignalRStatus(status, color) {
         const statusElement = document.getElementById('signalRStatus');
         if (statusElement) {
             statusElement.textContent = status;
             statusElement.style.backgroundColor = color;
             statusElement.style.color = 'white';
         }
     }
     
              // Function to set up SignalR event listeners
         function setupSignalRListeners() {
             // Prevent duplicate event listeners
             if (window.signalRListenersSet) {
                 return;
             }
             
             // Listen for real-time ride updates
             connection.on("RideStarted", function (rideId) {
                 if (rideId == @Model.Id) {
                     // Update UI to show ride started
                     document.querySelector('.ride-status-info').innerHTML = '<span style="padding: 5px 12px; background-color: #ffc107; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">In Progress</span>';
                     document.querySelector('.ride-status-info h4').textContent = 'üöÄ Ride Started';
                     document.querySelector('.ride-status-info p').textContent = 'Your ride is now in progress!';
                     document.querySelector('.ride-status-info').style.backgroundColor = '#fff3cd';
                     document.querySelector('.ride-status-info').style.borderLeftColor = '#ffc107';
                 }
             });
 
             connection.on("RideCompleted", function (rideId) {
                 if (rideId == @Model.Id) {
                     // Update UI to show ride completed
                     document.querySelector('.ride-status-info').innerHTML = '<span style="padding: 5px 12px; background-color: #28a745; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">Completed</span>';
                     document.querySelector('.ride-status-info h4').textContent = '‚úÖ Ride Completed';
                     document.querySelector('.ride-status-info p').textContent = 'Your ride has been completed successfully!';
                     document.querySelector('.ride-status-info').style.backgroundColor = '#e8f5e8';
                     document.querySelector('.ride-status-info').style.borderLeftColor = '#28a745';
                 }
             });
 
             connection.on("RideCancelled", function (rideId) {
                 if (rideId == @Model.Id) {
                     // Update UI to show ride cancelled
                     updateRideStatusDisplay("Cancelled");
                     
                     // Hide the cancel button
                     const cancelBtn = document.getElementById('cancelRideBtn');
                     if (cancelBtn) {
                         cancelBtn.style.display = 'none';
                     }
                     
                     // Show the Back to Home button
                     showBackToHomeButton();
                     
                     // Show cancellation message
                     alert("Ride has been cancelled.");
                 }
             });
             
             // Mark listeners as set up
             window.signalRListenersSet = true;
    }

    // Driver functions
    function startRide() {
        if (confirm("Are you sure you want to start the ride?")) {
            updateRideStatus("InProgress", @Model.Id);
        }
    }

    function completeRide() {
        if (confirm("Are you sure you complete the ride?")) {
            updateRideStatus("Completed", @Model.Id);
        }
    }

        // Cancel ride function for both roles
    async function cancelRide() {
        if (confirm("Are you sure you want to cancel this ride?")) {
            try {
                                 // Ensure SignalR connection is ready
                 if (!connection || !isConnected) {
                     await initializeConnection();
                     
                     // Wait a bit for connection to stabilize
                     await new Promise(resolve => setTimeout(resolve, 1000));
                 }
                 
                 const response = await fetch('/Ride/CancelRide', {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
                     },
                     body: JSON.stringify({ 
                         id: @Model.Id, 
                         rideGroup: 'ride-@Model.Id' 
                     })
                 });

                 if (response.ok) {
                     const data = await response.json();
                     
                     // Hide the cancel button immediately
                     const cancelBtn = document.getElementById('cancelRideBtn');
                     if (cancelBtn) {
                         cancelBtn.style.display = 'none';
                     }
                     
                     // Update ride status display immediately
                     updateRideStatusDisplay("Cancelled");
                     
                     // Show success message
                     alert(data.message);
                 } else {
                     const errorData = await response.json();
                     alert("Error cancelling ride: " + (errorData.message || "Unknown error"));
                 }
            } catch (err) {
                console.error("Error:", err);
                alert("Error cancelling ride. Please try again.");
            }
        }
    }

    async function updateRideStatus(status, rideId) {
        try {
            let endpoint = '';
            if (status === 'InProgress') {
                endpoint = '/Ride/StartRide';
            } else if (status === 'Completed') {
                endpoint = '/Ride/CompleteRide';
            }

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ rideId: rideId })
            });

            if (response.ok) {
                const data = await response.json();
                alert(data.message);
                
                // Update the UI based on the new status
                if (status === 'InProgress') {
                    document.querySelector('.ride-status-info').innerHTML = '<span style="padding: 5px 12px; background-color: #ffc107; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">In Progress</span>';
                    document.querySelector('.ride-status-info h4').textContent = 'üöÄ Ride Started';
                    document.querySelector('.ride-status-info p').textContent = 'Your ride is now in progress!';
                    document.querySelector('.ride-status-info').style.backgroundColor = '#fff3cd';
                    document.querySelector('.ride-status-info').style.borderLeftColor = '#ffc107';
                } else if (status === 'Completed') {
                    document.querySelector('.ride-status-info').innerHTML = '<span style="padding: 5px 12px; background-color: #28a745; color: white; border-radius: 15px; font-size: 12px; font-weight: bold;">Completed</span>';
                    document.querySelector('.ride-status-info h4').textContent = '‚úÖ Ride Completed';
                    document.querySelector('.ride-status-info p').textContent = 'Your ride has been completed successfully!';
                    document.querySelector('.ride-status-info').style.backgroundColor = '#e8f5e8';
                    document.querySelector('.ride-status-info').style.borderLeftColor = '#28a745';
                }
            } else {
                const errorData = await response.json();
                alert("Error updating ride status: " + (errorData.message || "Unknown error"));
            }
        } catch (err) {
            console.error("Error:", err);
            alert("Error updating ride status. Please try again.");
        }
    }

    // Function to update ride status display
    function updateRideStatusDisplay(status) {
        const statusInfo = document.querySelector('.ride-status-info');
        const statusBadge = document.getElementById('statusBadge');
        
        if (statusInfo) {
            if (status === "Cancelled") {
                // Update the status info section
                statusInfo.innerHTML = `
                    <h4 style="color: #dc3545; margin: 0;">‚ùå Ride Cancelled</h4>
                    <p style="margin: 10px 0 0 0; color: #721c24;">This ride has been cancelled.</p>
                `;
                statusInfo.style.backgroundColor = '#f8d7da';
                statusInfo.style.borderLeftColor = '#dc3545';
            }
        }
        
        if (statusBadge) {
            if (status === "Cancelled") {
                statusBadge.textContent = "Cancelled";
                statusBadge.style.backgroundColor = "#dc3545";
            }
        }
        
        // Show the Back to Home button when ride is cancelled
        if (status === "Cancelled") {
            showBackToHomeButton();
        }
    }
    
    // Function to show the Back to Home button
    function showBackToHomeButton() {
        // Create the Back to Home button if it doesn't exist
        let backButton = document.querySelector('.back-to-home-btn');
        if (!backButton) {
            backButton = document.createElement('a');
            backButton.href = '/Home';
            backButton.className = 'back-to-home-btn';
            backButton.style.cssText = 'display: inline-block; padding: 15px 30px; background-color: #6c757d; color: white; text-decoration: none; border-radius: 8px; font-size: 16px; margin: 0 10px;';
            backButton.innerHTML = 'üè† Back to Home';
            
            // Insert after the action buttons div
            const actionButtonsDiv = document.querySelector('.action-buttons');
            if (actionButtonsDiv) {
                actionButtonsDiv.appendChild(backButton);
            }
        }
    }

    // SignalR event listeners are now set up in setupSignalRListeners() function
    // which is called after the connection is established

    // Initialize everything when page loads
     document.addEventListener('DOMContentLoaded', async function() {

         
         // Check if ride is already cancelled and update UI accordingly
         const currentStatus = '@Model.Status.ToString()';
         if (currentStatus === 'Cancelled') {
             updateRideStatusDisplay("Cancelled");
             
             // Hide the cancel button if ride is already cancelled
             const cancelBtn = document.getElementById('cancelRideBtn');
             if (cancelBtn) {
                 cancelBtn.style.display = 'none';
             }
             
             // Show the Back to Home button if ride is already cancelled
             showBackToHomeButton();
         }
         
         // Initialize SignalR status
         updateSignalRStatus("Initializing...", "#6c757d");
         
         // AUTO-CONNECT SIGNALR IMMEDIATELY
         try {
             await initializeConnection();
         } catch (error) {
             console.error('SignalR auto-connection failed:', error);
             // Retry after a delay
             setTimeout(async () => {
                 try {
                     await initializeConnection();
                 } catch (retryError) {
                     console.error('SignalR retry failed:', retryError);
                 }
             }, 2000);
         }
         
                            const mapContainer = document.getElementById('rideMap');
        
        // Check if container has proper dimensions
        if (mapContainer && (mapContainer.offsetWidth === 0 || mapContainer.offsetHeight === 0)) {
            console.warn('Map container has zero dimensions, this might cause the map not to appear');
        }
        
        // Try immediate initialization first
         if (typeof L !== 'undefined' && mapContainer && mapContainer.offsetWidth > 0 && mapContainer.offsetHeight > 0 && !window.mapInitialized) {
            try {
                initializeMap();
                return;
            } catch (error) {
                     // Fall back to retry logic
                 }
         }
         
         // Start automatic map initialization with retry logic (only if not already initialized)
         if (!window.mapInitialized) {
             autoInitializeMap();
         }
    });
    
    // Also try to initialize when window is fully loaded (backup)
         window.addEventListener('load', async function() {
             // Ensure SignalR is connected
             if (!connection || !isConnected) {
                 try {
                     await initializeConnection();
                 } catch (error) {
                     console.error('Failed to connect SignalR on window load:', error);
                 }
             }
             
             // Only initialize map if it hasn't been initialized yet
             if (!map && !window.mapInitialized) {
            autoInitializeMap();
        }
    });
    
    // Automatic map initialization with retry logic
         async function autoInitializeMap() {
             // Prevent multiple auto-initialization calls
             if (window.autoInitInProgress) {
                 return;
             }
             
             // Prevent if map is already initialized
             if (window.mapInitialized) {
                 return;
             }
             
             window.autoInitInProgress = true;
        
        // Check if Leaflet is loaded
        if (typeof L === 'undefined') {
            // Retry after a short delay
                 setTimeout(() => {
                     window.autoInitInProgress = false;
                     autoInitializeMap();
                 }, 200);
            return;
        }
        
        // Check if map container is ready
        const mapContainer = document.getElementById('rideMap');
        if (!mapContainer || mapContainer.offsetWidth === 0 || mapContainer.offsetHeight === 0) {
            // Retry after a short delay
                 setTimeout(() => {
                     window.autoInitInProgress = false;
                     autoInitializeMap();
                 }, 200);
            return;
        }
        
        try {
            // Initialize the map
            initializeMap();
        } catch (error) {
                 console.error('Error during automatic map initialization:', error);
            
            // Retry after a longer delay
                 setTimeout(() => {
                     window.autoInitInProgress = false;
                     autoInitializeMap();
                 }, 1000);
             } finally {
                 window.autoInitInProgress = false;
             }
         }

    
</script>
